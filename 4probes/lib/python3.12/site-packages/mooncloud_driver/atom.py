# from __future__ import annotations

import abc
import dataclasses
import enum
import inspect
import typing

# import abstract_driver
# import exceptions
# import abstract_driver
import mooncloud_driver.result as result

if typing.TYPE_CHECKING:
    import mooncloud_driver.abstract_probe as abstract_probe


def empty_action():
    pass


TAny = typing.TypeVar('TAny')


def passthrough_action(inputs: typing.Optional[TAny]) -> typing.Optional[TAny]:
    return inputs


class AtomExecutionMode(enum.Enum):
    FORWARD = 'FORWARD'
    ROLLBACK = 'ROLLBACK'


# Basically it creates a new type that can be used as a generic type
# i.e., like class<T extents TException>
# covariant means that a function generic over TException
# is valid when instantiated with subclasses of TException.
TException = typing.TypeVar('TException', bound=Exception, covariant=True)


def default_result_producer(e: Exception) -> result.Result:
    base = result.Result(
        pretty_result='An error happened',
        base_extra_data={'ErrorType': type(e).__name__}
    )
    if hasattr(e, '__str__'):
        base.base_extra_data['Details'] = str(e)
    return base


@dataclasses.dataclass
class BaseExceptionInformation(abc.ABC):
    # partial_result: result.Result
    # exception_class: typing.Type[Exception]
    exception_class: typing.Type[TException]
    # Called over an instance of exception class to return the corresponding.
    # I can use an interface, but it requires to extend the base interface,
    # this approach is less complicated.
    result_producer: typing.Optional[typing.Callable[[TException], result.Result]] = dataclasses.field(
        default=default_result_producer)
    partial_result_destructive_merge: bool = dataclasses.field(default=False)


class OnExceptionActionRollback(enum.Enum):
    GO_ON = 'go_in'
    STOP = 'stop'


@dataclasses.dataclass
class PunctualExceptionInformationRollback(BaseExceptionInformation):

    # can_proceed_to_same_direction: bool = dataclasses.field(default=True)
    action: OnExceptionActionRollback = dataclasses.field(default=OnExceptionActionRollback.GO_ON)

    @staticmethod
    def from_global(other: "GlobalExceptionInformation") -> "PunctualExceptionInformationRollback":
        return PunctualExceptionInformationRollback(
            exception_class=other.exception_class,
            result_producer=other.result_producer,
            partial_result_destructive_merge=other.partial_result_destructive_merge,
            action=other.on_rollback
        )


class OnExceptionActionForward(enum.Enum):
    GO_ON = 'go_on'
    ROLLBACK = 'rollback'
    STOP = 'stop'


@dataclasses.dataclass
class PunctualExceptionInformationForward(BaseExceptionInformation):
    action: OnExceptionActionForward = dataclasses.field(default=OnExceptionActionForward.ROLLBACK)

    @staticmethod
    def from_global(other: "GlobalExceptionInformation") -> "PunctualExceptionInformationForward":
        return PunctualExceptionInformationForward(
            exception_class=other.exception_class,
            result_producer=other.result_producer,
            partial_result_destructive_merge=other.partial_result_destructive_merge,
            action=other.on_forward
        )


@dataclasses.dataclass
class GlobalExceptionInformation(BaseExceptionInformation):
    """
    This class represents ExceptionInformation used globally, i.e., applied
    to all atoms.

    It is basically a convenience data structure, since at low-level, it is associated to each
    atom in the chain and, there, converted into a PunctualExceptionInformationRollback and
    PunctualExceptionInformationForward
    """
    # can_proceed_to_forward: bool = dataclasses.field(default=False)
    # can_proceed_to_rollback: bool = dataclasses.field(default=False)
    # can_proceed_to_start_rollback: bool = dataclasses.field(default=True)
    on_forward: OnExceptionActionForward = dataclasses.field(default=OnExceptionActionForward.ROLLBACK)
    on_rollback: OnExceptionActionRollback = dataclasses.field(default=OnExceptionActionRollback.GO_ON)


@dataclasses.dataclass
class AtomPairWithException:
    forward: typing.Callable[[typing.Optional[typing.Any]], typing.Optional[typing.Any]]
    forward_captured_exceptions: typing.List[PunctualExceptionInformationForward] = dataclasses.field(
        default_factory=list)
    rollback_captured_exceptions: typing.List[PunctualExceptionInformationRollback] = dataclasses.field(
        default_factory=list)
    rollback: typing.Optional[
        typing.Callable[[typing.Optional[typing.Any]], typing.Optional[typing.Any]]] = dataclasses.field(
        default=empty_action)

    def execute(self,
                modality: AtomExecutionMode,
                inputs: typing.Optional[typing.Any] = None) -> typing.Optional[typing.Any]:
        atom_to_execute = self.forward if modality == AtomExecutionMode.FORWARD else self.rollback
        signature = inspect.signature(atom_to_execute)
        # this is a trick allowing us to have functions with no parameters than self.
        if ('self' not in signature.parameters and len(signature.parameters) == 1) or \
                ('self' in signature.parameters and len(signature.parameters) == 2):
            return atom_to_execute(inputs)
        else:
            # ignore this warning, I have just to figure out
            # the correct type annotations of the above
            return atom_to_execute()

    def get_current_exceptions(self, modality: AtomExecutionMode) -> typing.List[BaseExceptionInformation]:
        return self.forward_captured_exceptions if modality == AtomExecutionMode.FORWARD \
            else self.rollback_captured_exceptions

    def get_current_known_exception(self, modality: AtomExecutionMode,
                                    thrown: Exception) -> typing.Optional[BaseExceptionInformation]:
        current_exceptions = self.get_current_exceptions(modality=modality)
        for current_exception in current_exceptions:
            if isinstance(thrown, current_exception.exception_class):
                return current_exception
        return None


class AtomIterator:
    """
    This class handles the execution of the state machine.

    Executing an individual atom is a 2-step process where
    1. the atom at the current position is executed
    2. the current position is adjusted for the next atom, according to the result of the execution.

    The current position reflects the position for the NEXT execution, and is always valid
    (i.e., it never overflows).
    """

    def __init__(self,
                 atom_interface: "abstract_probe.AbstractProbe",
                 # base_result: typing.Optional[result.Result] = None,
                 global_exceptions: typing.Optional[typing.Sequence[GlobalExceptionInformation]] = None
                 ):

        self.atom_interface = atom_interface
        self.final_atoms = self.atom_interface.atoms()

        if global_exceptions is None:
            global_exceptions = list()

        for single_atom_index in range(len(self.final_atoms)):
            forward_exceptions_classes = [exception_info.exception_class
                                          for exception_info in
                                          self.final_atoms[single_atom_index].forward_captured_exceptions]
            rollback_exceptions_classes = [exception_info.exception_class
                                           for exception_info in
                                           self.final_atoms[single_atom_index].rollback_captured_exceptions]
            # add each global exception to the list of local exceptions
            # for each atom, in both directions.
            for global_exception in global_exceptions:
                if global_exception.exception_class not in forward_exceptions_classes:
                    self.final_atoms[single_atom_index].forward_captured_exceptions.append(
                        PunctualExceptionInformationForward.from_global(global_exception))
                if global_exception.exception_class not in rollback_exceptions_classes:
                    self.final_atoms[single_atom_index].rollback_captured_exceptions.append(
                        PunctualExceptionInformationRollback.from_global(global_exception))

        # self.atoms: typing.Sequence[AtomPairWithException] = atoms
        # self.base_result: result.Result = base_result if base_result is not None else result.Result.empty()
        self.execution_mode = AtomExecutionMode.FORWARD
        self.cursor = 0
        # the most recent output returned by the last executed pair.
        self.last_output: typing.Optional[typing.Any] = None

    def _move_cursor(self, flow_change: bool = False, flow_over: bool = False):
        """
        Move the current position for the next execution.
        The management of the current position (cursor) is hidden from the outside,
        except for flow_change which signals whether the forward direction must change,
        and flow_over which signals whether the execution should be stopped, because, e.g.,
        an unhandled exception has been throw.

        :param flow_change: True if we have to start rolling back.
        :param flow_over: True if the execution should be stopped
        :return:
        :raise StopIteration to signal the end of the execution.
        """

        if flow_over:
            raise StopIteration

        if flow_change:
            # just change the modality, and do not alter the current cursor.
            # because we are going to start right here.
            self.execution_mode = AtomExecutionMode.ROLLBACK
        elif self.execution_mode == AtomExecutionMode.FORWARD:
            # if we are forwarding, we move forward the cursor if we have room.
            if self.cursor == len(self.final_atoms) - 1:
                raise StopIteration
            else:
                # increase the cursor of 1 position.
                self.cursor += 1
        else:
            # if we are rolling back, we move backward the cursor if we have room.
            if self.cursor == -1:
                raise StopIteration
            else:
                self.cursor -= 1

    # @staticmethod
    # def can_proceed_to_same_direction_backward(thrown: BaseExceptionInformation) -> bool:
    #     assert isinstance(thrown, PunctualExceptionInformationRollback)
    #     return thrown.can_proceed_to_same_direction
    #
    # @staticmethod
    # def can_proceed_to_same_direction_in_forward(thrown: BaseExceptionInformation):
    #     """
    #     Determines whether when we are forwarding, have recovered from
    #     :param thrown:
    #     :return:
    #     """
    #     assert isinstance(thrown, PunctualExceptionInformationForward)
    #     if not thrown.can_proceed_to_start_rollback and not thrown.can_proceed_to_same_direction:
    #         raise StopIteration
    #     else:
    #         return thrown.can_proceed_to_same_direction

    @property
    def current_atom_pair(self) -> AtomPairWithException:
        return self.final_atoms[self.cursor]

    def __iter__(self) -> typing.Iterable[typing.Optional[typing.Any]]:
        return self

    def __next__(self):
        flow_change = False
        flow_over = False

        try:
            self.last_output = self.current_atom_pair.execute(modality=self.execution_mode, inputs=self.last_output)
        except Exception as e:
            # first, let's try to find out if the exception is known
            recovered_exception = self.current_atom_pair.get_current_known_exception(self.execution_mode, thrown=e)
            # find what to do according to the current modality
            if self.execution_mode == AtomExecutionMode.FORWARD:
                # if the exception is not known, then the only thing to do is
                # to rollback, so we change the modality.
                if recovered_exception is None:
                    flow_change = True
                else:
                    # if the exception is known, it may allow us to:
                    #   - proceed in the same direction
                    #   - start rolling back
                    #   - stop the iteration.
                    # just a type check (it is always the case)
                    assert isinstance(recovered_exception, PunctualExceptionInformationForward)
                    if recovered_exception.action == OnExceptionActionForward.ROLLBACK:
                        flow_change = True
                    elif recovered_exception.action == OnExceptionActionForward.STOP:
                        flow_over = True
                    # there is no branch GO_ON because it does not involve any manipulation
                    # on the two variables regulating the next move of the cursor.

            else:
                # if we are rolling back, we can either
                #   - proceed if the exception is known, and it allows us to do so.
                #   - interrupt if the exception is not known , or is known and it does not allow us to do so.

                # so basically, here we are not going to alter the direction,
                # but we just find out if we can go on. In other words, we stop if:
                # - the exception is not known
                # - the exception is known but it does not allow us to proceed.
                if recovered_exception is None:
                    flow_over = True
                else:
                    assert isinstance(recovered_exception, PunctualExceptionInformationRollback)
                    if recovered_exception.action == OnExceptionActionRollback.STOP:
                        flow_over = True
                    # we do not need the other branch, since it does not alter the two flags
                    # flow_change and flow_over.

            # now handling the result contained within the exception.
            if recovered_exception is not None:
                # now, recover the result contained within the exception
                # using the function pointer.Tem
                if recovered_exception.result_producer is not None:
                    partial_result = recovered_exception.result_producer(e)
                    self.atom_interface.result.merge(
                        other=partial_result,
                        preserve_initial=not recovered_exception.partial_result_destructive_merge)
            else:
                partial_result = result.Result(
                    integer_result=result.INTEGER_RESULT_MOON_CLOUD_ERROR,
                    pretty_result='Internal error occurred.',
                    base_extra_data={'Details': str(e)}
                )
                self.atom_interface.result.merge(
                        other=partial_result,
                        preserve_initial=True)
        self._move_cursor(flow_change=flow_change, flow_over=flow_over)
        return self.last_output

    def run(self):
        for _ in self:
            pass
