import typing

import pytest

import mooncloud_driver.abstract_probe as abstract_probe
import mooncloud_driver.atom as atom
import mooncloud_driver.result as result


def inner_test_probe(probe_class: typing.Optional[typing.Type[abstract_probe.AbstractProbe]] = None,
                     probe: typing.Optional[abstract_probe.AbstractProbe] = None,
                     expected_result: typing.Optional[result.Result] = None,
                     last_returned: typing.Optional[typing.Any] = None):
    assert probe_class is not None or probe is not None

    if probe_class is not None:
        probe = probe_class()

    it = atom.AtomIterator(atom_interface=probe)
    it.run()

    if expected_result is not None:
        assert probe.result == expected_result

    if last_returned is not None:
        assert it.last_output == last_returned


def test_straightforward():
    class TestProbe(abstract_probe.AbstractProbe):

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'hello'),
                atom.AtomPairWithException(forward=lambda inputs: f'{inputs}, is there anybody in there?'),
            ]

    inner_test_probe(probe_class=TestProbe, last_returned='hello, is there anybody in there?')


def test_passthrough():
    class TestProbe(abstract_probe.AbstractProbe):

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'hello, is there anybody in there?'),
                atom.AtomPairWithException(forward=atom.passthrough_action),
            ]

    inner_test_probe(probe_class=TestProbe, last_returned='hello, is there anybody in there?')


def test_with_exception_forward_go_on_allowed():
    """
    Here we probe an exception in the forward chain that allows us to proceed,
    it just alters the result.
    :return:
    """

    class TestProbe(abstract_probe.AbstractProbe):

        def atom_raising(self):
            raise Exception('This is an exception')

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'hello, is there anybody in there?',
                                           rollback=atom.empty_action),
                atom.AtomPairWithException(forward=self.atom_raising,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=Exception,
                                                   action=atom.OnExceptionActionForward.GO_ON,
                                                   result_producer=lambda e: result.Result(
                                                       pretty_result='Hello, I recovered',
                                                       base_extra_data={'Type': type(e).__name__,
                                                                        'Message': str(e)}
                                                   ),
                                               )
                                           ],
                                           rollback=atom.empty_action),
            ]

    inner_test_probe(probe_class=TestProbe,
                     last_returned='hello, is there anybody in there?',
                     expected_result=result.Result(
                         pretty_result='Hello, I recovered',
                         base_extra_data={'Type': 'Exception', 'Message': 'This is an exception'}
                     ))


def test_with_exception_forward_can_rollback():
    class TestProbe(abstract_probe.AbstractProbe):

        def atom_raising(self):
            raise Exception('This is an exception')

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'hello, is there anybody in there?',
                                           rollback=atom.passthrough_action),
                atom.AtomPairWithException(forward=self.atom_raising,
                                           rollback=atom.passthrough_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=Exception,
                                                   result_producer=None
                                               )
                                           ])
            ]

    inner_test_probe(probe_class=TestProbe,
                     last_returned='hello, is there anybody in there?',
                     # empty because we don't touch it.
                     expected_result=result.Result.empty())


def test_with_unknown_exception():
    class TestProbe(abstract_probe.AbstractProbe):

        def atom_raising(self):
            raise Exception()

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'Hello, is there anybody in there?',
                                           rollback=atom.passthrough_action),
                atom.AtomPairWithException(forward=self.atom_raising,
                                           rollback=atom.passthrough_action),
            ]

    # the trick we use here to make sure that the rollback works is the exploit the passing
    # inputs
    # 1. atom1 --> atom_raising
    # 2. atom_raising_rollback --> passthrough to first rollback item
    # 3. rollback item --> final.
    inner_test_probe(probe_class=TestProbe, last_returned='Hello, is there anybody in there?')


def test_with_blocking_known_exception():
    """
    Here we probe the capturing of a known exception which still does not permit us
    to go on, nor to rollback.
    :return:
    """

    class TestProbe(abstract_probe.AbstractProbe):

        def atom_raising(self):
            raise Exception('Exit light, enter night')

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'Don\'t forget my son, to include...',
                                           rollback=atom.empty_action),
                atom.AtomPairWithException(forward=self.atom_raising,
                                           rollback=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=Exception,
                                                   action=atom.OnExceptionActionForward.STOP,
                                                   partial_result_destructive_merge=False,
                                                   result_producer=lambda e: result.Result(
                                                       pretty_result='Don\'t forget my son, to include...',
                                                       base_extra_data={}
                                                   )
                                               )
                                           ]),
            ]

    inner_test_probe(probe_class=TestProbe,
                     last_returned='Don\'t forget my son, to include...',
                     expected_result=result.Result(pretty_result='Don\'t forget my son, to include...',
                                                   base_extra_data={}))


def test_unknown_exception_during_rollback():
    """
    An unknown exception during rollback causes the flow to block.

    So we put a rollback *before* the rollback where the unknown
    exception is thrown, and we make sure it has never been called.
    :return:
    """

    class TestProbe(abstract_probe.AbstractProbe):

        def atom_set_result(self):
            self.result.put_extra_data('Safe', 'in the light that surrounds me')

        def atom_raise(self):
            raise Exception()

        def atom_should_not_be_called(self):
            self.result.put_extra_data('Victoria', 'is real')

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=self.atom_set_result,
                                           # 3. so this rollback will never be called.
                                           rollback=self.atom_should_not_be_called),
                # 2. here rollback finishes because it encounters an unknown Exception.
                atom.AtomPairWithException(forward=atom.empty_action,
                                           rollback=self.atom_raise),
                # 1. here rollback starts
                atom.AtomPairWithException(forward=self.atom_raise)
            ]

    inner_test_probe(probe_class=TestProbe,
                     expected_result=result.Result(base_extra_data={'Safe': 'in the light that surrounds me'}))


def test_known_exception_during_rollback_blocking():
    """
    A known exception during rollback can make the flow:
    - to still rolling back
    - to stop.

    Here we probe the second behavior, basically, with the same structure of above.
    :return:
    """

    class TestProbe(abstract_probe.AbstractProbe):

        def atom_raise(self):
            raise Exception()

        def atom_should_not_be_called(self):
            self.result.put_extra_data('Victoria', 'is real')

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=atom.empty_action,
                                           # 3. so this rollback will never be called.
                                           rollback=self.atom_should_not_be_called),
                # 2. here rollback finishes because it encounters an unknown Exception.
                atom.AtomPairWithException(forward=atom.empty_action,
                                           rollback=self.atom_raise,
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=Exception,
                                                   result_producer=lambda e: result.Result(
                                                       pretty_result='Caught',
                                                       base_extra_data={'Move on': 'be brave'}),
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )]
                                           ),
                # 1. here rollback starts
                atom.AtomPairWithException(forward=self.atom_raise)
            ]

    inner_test_probe(probe_class=TestProbe,
                     expected_result=result.Result(pretty_result='Caught', base_extra_data={'Move on': 'be brave'}), )


def test_known_exception_during_rollback_allowing():
    """
    A known exception during rollback can make the flow:
    - to still rolling back
    - to stop.

    Here we probe the first behavior, basically, with the opposite structure of above.
    Here we use passthrough rather than results to check it.
    :return:
    """

    class TestProbe(abstract_probe.AbstractProbe):

        def atom_raise(self):
            raise Exception()

        def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
            return [
                atom.AtomPairWithException(forward=lambda: 'Cause I am no longer here',
                                           # 3. so this rollback will never be called.
                                           rollback=atom.passthrough_action),
                # 2. here rollback finishes because it encounters an unknown Exception.
                atom.AtomPairWithException(forward=atom.passthrough_action,
                                           rollback=self.atom_raise,
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=Exception,
                                                   result_producer=lambda e: result.Result(
                                                       pretty_result='Caught',
                                                       base_extra_data={'Move on': 'be brave'}),
                                                   action=atom.OnExceptionActionRollback.GO_ON,
                                               )]
                                           ),
                # 1. here rollback starts
                atom.AtomPairWithException(forward=self.atom_raise,
                                           rollback=atom.passthrough_action)
            ]

    inner_test_probe(probe_class=TestProbe,
                     expected_result=result.Result(pretty_result='Caught', base_extra_data={'Move on': 'be brave'}),
                     last_returned='Cause I am no longer here')


class SimpleTestProbe(abstract_probe.AbstractProbe):

    def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
        return [
            atom.AtomPairWithException(forward=atom.empty_action),
            atom.AtomPairWithException(forward=atom.empty_action,
                                       rollback=atom.empty_action,
                                       forward_captured_exceptions=[
                                           atom.PunctualExceptionInformationForward(
                                               exception_class=IndexError,
                                               action=atom.OnExceptionActionForward.GO_ON
                                           )
                                       ],
                                       rollback_captured_exceptions=[
                                           atom.PunctualExceptionInformationRollback(
                                               exception_class=IndexError,
                                               action=atom.OnExceptionActionRollback.GO_ON
                                           )]
                                       ),
            atom.AtomPairWithException(forward=atom.empty_action,
                                       rollback=atom.empty_action,
                                       forward_captured_exceptions=[
                                           atom.PunctualExceptionInformationForward(
                                               exception_class=IndexError,
                                               action=atom.OnExceptionActionForward.STOP
                                           )
                                       ],
                                       rollback_captured_exceptions=[
                                           atom.PunctualExceptionInformationRollback(
                                               exception_class=IndexError,
                                               action=atom.OnExceptionActionRollback.STOP
                                           )
                                       ]),
            atom.AtomPairWithException(forward=atom.empty_action,
                                       rollback=atom.empty_action,
                                       forward_captured_exceptions=[
                                           atom.PunctualExceptionInformationForward(
                                               exception_class=IndexError,
                                               action=atom.OnExceptionActionForward.ROLLBACK
                                           ),
                                           atom.PunctualExceptionInformationForward(
                                               exception_class=ValueError,
                                               action=atom.OnExceptionActionForward.STOP,
                                           )
                                       ],
                                       rollback_captured_exceptions=[
                                           atom.PunctualExceptionInformationRollback(
                                               exception_class=IndexError,
                                               action=atom.OnExceptionActionRollback.STOP
                                           ),
                                           atom.PunctualExceptionInformationRollback(
                                               exception_class=ValueError,
                                               action=atom.OnExceptionActionRollback.STOP,
                                           )]
                                       ),
        ]


@pytest.mark.parametrize('probe_class, global_exceptions, expected_atoms', [
    # here, we just add another global exception
    (
            SimpleTestProbe,
            [
                atom.GlobalExceptionInformation(
                    exception_class=KeyError,
                    result_producer=atom.default_result_producer,
                    on_forward=atom.OnExceptionActionForward.STOP,
                    on_rollback=atom.OnExceptionActionRollback.STOP,
                )
            ],
            [
                atom.AtomPairWithException(forward=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionForward.STOP
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )
                                           ]),
                atom.AtomPairWithException(forward=atom.empty_action,
                                           rollback=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.GO_ON
                                               ),
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionForward.STOP
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.GO_ON
                                               ),
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )
                                           ]
                                           ),
                atom.AtomPairWithException(forward=atom.empty_action,
                                           rollback=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.STOP
                                               ),
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionForward.STOP
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.STOP
                                               ),
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )
                                           ]),
                atom.AtomPairWithException(forward=atom.empty_action,
                                           rollback=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.ROLLBACK
                                               ),
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=ValueError,
                                                   action=atom.OnExceptionActionForward.STOP,
                                               ),
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionForward.STOP
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.STOP
                                               ),
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=ValueError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               ),
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=KeyError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )
                                           ]
                                           ),
            ]
    ),
    # here, we probe the addition of a global
    # exception that is added only at the first atom only
    # and does not overwrite the other ones,
    (
            SimpleTestProbe,
            [
                atom.GlobalExceptionInformation(
                    exception_class=IndexError,
                    result_producer=atom.default_result_producer,
                    on_forward=atom.OnExceptionActionForward.STOP,
                    on_rollback=atom.OnExceptionActionRollback.STOP,
                )
            ],
            [
                # here, we expect the IndexError to be added, while in the next ones
                # we do not expect any changes.
                atom.AtomPairWithException(forward=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.STOP,
                                               )],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )]
                                           ),
                atom.AtomPairWithException(forward=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.GO_ON
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.GO_ON
                                               )]
                                           ),
                atom.AtomPairWithException(forward=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.STOP
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.STOP
                                               )
                                           ]),
                atom.AtomPairWithException(forward=atom.empty_action,
                                           forward_captured_exceptions=[
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionForward.ROLLBACK
                                               ),
                                               atom.PunctualExceptionInformationForward(
                                                   exception_class=ValueError,
                                                   action=atom.OnExceptionActionForward.STOP,
                                               )
                                           ],
                                           rollback_captured_exceptions=[
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=IndexError,
                                                   action=atom.OnExceptionActionRollback.STOP
                                               ),
                                               atom.PunctualExceptionInformationRollback(
                                                   exception_class=ValueError,
                                                   action=atom.OnExceptionActionRollback.STOP,
                                               )]
                                           ),
            ]
    )
])
def test_annotator(probe_class: typing.Type[abstract_probe.AbstractProbe],
                   global_exceptions: typing.Sequence[atom.GlobalExceptionInformation],
                   expected_atoms: typing.Sequence[atom.AtomPairWithException], ):
    probe = probe_class()

    it = atom.AtomIterator(atom_interface=probe, global_exceptions=global_exceptions)
    print(it.atom_interface.atoms())
    assert it.final_atoms == expected_atoms


def test_default_result_producer():
    obtained = atom.default_result_producer(Exception('Hello, is there anybody in there?'))
    assert obtained == result.Result(
        pretty_result='An error happened',
        base_extra_data={'ErrorType': 'Exception', 'Details': 'Hello, is there anybody in there?'}
    )
