import abc
import dataclasses
import json
import os
import sys
import typing

import jsonschema

import mooncloud_driver.exceptions as exceptions


@dataclasses.dataclass
class MetaConfig:
    input_path: str = '/etc/probe/input.json'
    schema_path: str = '/etc/probe/schema.json'
    credential_path : str = '/vault/secrets/secret.json'


@dataclasses.dataclass(frozen=True)
class Config:
    logger_name: str = dataclasses.field(default='Probe')
    user_evaluation_rule_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_UER_ID', '0')))
    abstract_evaluation_rule_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_AER_ID', '0')))
    test_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_TEST_ID', '0')))
    control_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_CONTROL_ID', '0')))
    target_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_TARGET_ID', '0')))
    zone_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_ZONE_ID', '0')))
    project_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_PROJECT_ID', '0')))
    user_id: int = dataclasses.field(
        default_factory=lambda: int(os.getenv('MOONCLOUD_PROBE_USER_ID', '0')))
    input: typing.Mapping = dataclasses.field(default_factory=dict)
    meta_config: MetaConfig = dataclasses.field(default_factory=MetaConfig)
    is_production: bool = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_IS_PRODUCTION', 'false').lower() == 'true')
    read_from_stdin: bool = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_READ_FROM_STDIN', 'true').lower() == 'true')
    # NATS conf from K8s manager injection
    nats_host: str = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_NATS_HOST','nats'))
    nats_port: str = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_NATS_PORT','4222'))
    nats_user: str = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_NATS_USER','probe'))
    nats_password: str = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_NATS_PASSWORD','pass'))
    nats_subject : str = dataclasses.field(
        default_factory=lambda: os.getenv('MOONCLOUD_PROBE_NATS_SUBJECT','results.user.0.uer.0'))
    # Credential secret from Vault sidecar injection
    credential: typing.Mapping = dataclasses.field(default_factory=dict)
    # Probe reference for specific configurations
    probe: dataclasses.InitVar[any]=None
    # A flag useful to create an empty config
    skip_init: dataclasses.InitVar[bool]=False

    def __post_init__(self,probe,skip_init):
        """
        :raise jsonschema.exceptions.ValidationError if the input is not valid
        :raise jsonschema.exceptions.SchemaError if the schema is not valid
        :return:
        """
        if not skip_init:
            if self.read_from_stdin:
                reader = InputAndSchemaFromStdinReader(config=self)
            else:
                #reader = InputAndSchemaReaderFromFile(config=self)
                reader = InputAndSchemaFromEnvReader(config=self)
            jsonschema.validate(instance=reader.input_data, schema=reader.schema)
            object.__setattr__(self, 'input', reader.input_data)
            if probe.requires_credential() is not None:
                if not self.is_production:
                    self.meta_config.credential_path=os.path.join(os.path.dirname(sys.modules['__main__'].__file__),'credential.json')
                with open(self.meta_config.credential_path) as secret_file:
                    secret_data = json.load(secret_file)
                    object.__setattr__(self, 'credential', secret_data)


class InputAndSchemaReaderAbstract(abc.ABC):

    def __init__(self, config: Config):
        self.config = config

        self.schema = self.open_schema()
        self.input_data = self.open_input()
        

    @abc.abstractmethod
    def open_schema(self) -> typing.Mapping:
        pass

    @abc.abstractmethod
    def open_input(self) -> typing.Mapping:
        pass


class InputAndSchemaReaderFromFile(InputAndSchemaReaderAbstract):

    def __init__(self, config: Config):
        super().__init__(config)

    def open_schema(self) -> typing.Mapping:
        if not self.config.is_production:
            self.config.meta_config.schema_path=os.path.join(os.path.dirname(sys.modules['__main__'].__file__),'schema.json')
        with open(self.config.meta_config.schema_path) as schema_file:
            return json.loads(schema_file.read())

    def open_input(self) -> typing.Mapping:
        if not os.path.exists(self.config.meta_config.input_path):
            self.config.meta_config.input_path=os.path.join(os.path.dirname(sys.modules['__main__'].__file__),'input.json')
        with open(self.config.meta_config.input_path) as input_file:
            return json.loads(input_file.read())

class InputAndSchemaFromStdinReader(InputAndSchemaReaderFromFile):

    def __init__(self, config: Config):
        super().__init__(config)

    def open_schema(self) -> typing.Mapping:
        return super().open_schema()

    def open_input(self) -> typing.Mapping:
        return json.load(sys.stdin)

class InputAndSchemaFromEnvReader(InputAndSchemaReaderFromFile):

    def __init__(self, config: Config):
        super().__init__(config)

    def open_schema(self) -> typing.Mapping:
        return super().open_schema()

    def open_input(self) -> typing.Mapping:
        return json.loads(os.getenv('input'))