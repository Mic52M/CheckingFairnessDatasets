#!/usr/bin/env python
import importlib
import json
import os.path
import pkgutil
import typing

import jsonschema

import mooncloud_driver.abstract_probe as abstract_probe
import mooncloud_driver.atom as atom
import mooncloud_driver.config as config
import mooncloud_driver.result as result
# import runtime
import mooncloud_driver.writer as writer


current_config: config.Config = config.Config(skip_init=True)
current_probe: abstract_probe.AbstractProbe = None
initial_result = result.Result.empty()

current_probe_class: typing.Type[abstract_probe.TAbstractProbe] = None
registered_exceptions: typing.Sequence[atom.GlobalExceptionInformation] = []


def register_global_exceptions(exceptions: typing.Sequence[atom.GlobalExceptionInformation]):
    global registered_exceptions
    # copy the list to avoid weird issues
    registered_exceptions = exceptions[:]


# the idea is to
# 1. create an initial probe that reads and parse the configuration, runs it using
# the executor. This helps us in using the same strategy for exception handling without
# messing things up.
# 2. run the actual probe.
class EntrypointProbe(abstract_probe.AbstractProbe):
    """
    The Entrypoint probe.
    """

    @staticmethod
    def atom_1():
        global current_config
        global current_probe
        global current_probe_class
        # instantiate the probe
        current_probe = current_probe_class()
        current_config = config.Config(probe=current_probe)
        current_probe.config = current_config

    def atom_2(self):
        # need to set the result to true to signal this init
        # process has been successful :)
        self.result.integer_result = result.INTEGER_RESULT_TRUE

    def atoms(self) -> typing.Sequence[atom.AtomPairWithException]:
        return [
            atom.AtomPairWithException(forward=self.atom_1,
                                       forward_captured_exceptions=[
                                           atom.PunctualExceptionInformationForward(
                                               action=atom.OnExceptionActionForward.STOP,
                                               exception_class=FileNotFoundError,
                                               result_producer=lambda e: result.Result(
                                                   integer_result=result.INTEGER_RESULT_INPUT_ERROR,
                                                   pretty_result='Probe cannot start',
                                                   base_extra_data={'Context': 'probe initialization',
                                                                    'Details': 'schema, input or credential file not found'}),
                                           ),
                                           atom.PunctualExceptionInformationForward(
                                               action=atom.OnExceptionActionForward.STOP,
                                               exception_class=json.JSONDecodeError,
                                               result_producer=lambda e: result.Result(
                                                   integer_result=result.INTEGER_RESULT_INPUT_ERROR,
                                                   pretty_result='Probe cannot start',
                                                   base_extra_data={
                                                       'Context': 'probe initialization',
                                                       'Details': 'schema, input or credential file not encoded correctly'}),
                                           ),
                                           atom.PunctualExceptionInformationForward(
                                               action=atom.OnExceptionActionForward.STOP,
                                               exception_class=jsonschema.ValidationError,
                                               result_producer=lambda e: result.Result(
                                                   integer_result=result.INTEGER_RESULT_INPUT_ERROR,
                                                   pretty_result='Probe cannot start',
                                                   base_extra_data={
                                                       'Context': 'probe initialization',
                                                       'Details': 'input is not valid'}),
                                           ),
                                           atom.PunctualExceptionInformationForward(
                                               action=atom.OnExceptionActionForward.STOP,
                                               exception_class=jsonschema.SchemaError,
                                               result_producer=lambda e: result.Result(
                                                   integer_result=result.INTEGER_RESULT_INPUT_ERROR,
                                                   pretty_result='Probe cannot start',
                                                   base_extra_data={
                                                       'Context': 'probe initialization',
                                                       'Details': 'schema is not valid'}),
                                           )]
                                       ),
            atom.AtomPairWithException(forward=self.atom_2),
        ]

def start_execution(probe_class):
    # import the probe class
    global current_probe_class
    current_probe_class = probe_class
    # ok, now instantiate it by passing to the executor
    entrypoint_probe_executor = atom.AtomIterator(atom_interface=EntrypointProbe())
    # now we run the executor.
    entrypoint_probe_executor.run()
    # if there has been some errors, we halt the execution.
    if entrypoint_probe_executor.atom_interface.result.integer_result != result.INTEGER_RESULT_TRUE:
        writer.write(current_config=current_config, 
                     result_to_write=entrypoint_probe_executor.atom_interface.result, 
                     hidden_data=entrypoint_probe_executor.atom_interface.hidden_data)
    else:
        probe_executor = atom.AtomIterator(atom_interface=current_probe)
        probe_executor.run()
        writer.write(result_to_write=probe_executor.atom_interface.result,
        current_config=current_config,
        hidden_data=probe_executor.atom_interface.hidden_data)
