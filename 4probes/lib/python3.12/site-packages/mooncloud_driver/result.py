import dataclasses
import typing

@dataclasses.dataclass
class EWMessage:
    text: str = dataclasses.field(default="")
    html: str = dataclasses.field(default="")

@dataclasses.dataclass
class EWStacktrace:
    trace: str = dataclasses.field(default="")

@dataclasses.dataclass
class EWResult:
    test_id:int = dataclasses.field(default=0)
    user_evaluation_rule_id:int = dataclasses.field(default=0)
    user_id:int = dataclasses.field(default=0)
    input:dict = dataclasses.field(default_factory=dict)
    message:EWMessage = dataclasses.field(default_factory=EWMessage)
    other_data:dict = dataclasses.field(default_factory=dict)
    extradata:dict = dataclasses.field(default_factory=dict)
    result:int = dataclasses.field(default=0)
    stack_trace:EWStacktrace = dataclasses.field(default_factory=EWStacktrace)

INTEGER_RESULT_TRUE = 0
INTEGER_RESULT_FALSE = 1
INTEGER_RESULT_TARGET_CONNECTION_ERROR = 2
INTEGER_RESULT_TARGET_EXECUTION_ERROR = 3
INTEGER_RESULT_INPUT_ERROR = 4
INTEGER_RESULT_MOON_CLOUD_ERROR = 5
INTEGER_RESULT_UNSPECIFIED = 6


class Result:

    def __init__(self, base_extra_data: typing.Dict,
                 integer_result: int = INTEGER_RESULT_FALSE,
                 pretty_result: str = '', ):
        self.integer_result: int = integer_result
        self.pretty_result: str = pretty_result
        self.base_extra_data: typing.Dict[str, typing.Any] = base_extra_data
        # TODO: add here hidden fields such as eval id and so
        # which are then added to extra_data

    def put_extra_data(self, key: str, value: typing.Any):
        self.base_extra_data[key] = value

    @staticmethod
    def empty():
        return Result(base_extra_data={}, pretty_result='', integer_result=INTEGER_RESULT_UNSPECIFIED)

    def merge(self, other: "Result", preserve_initial: bool = True):
        """
        Merge `other` in self. The merge can be destructive or not, i.e., result overwrite.
        This difference works only for extra_data, since for integer and pretty_result the merge
        is always destructive.
        :param other:
        :param preserve_initial:
        :return:
        """
        if other.integer_result != INTEGER_RESULT_UNSPECIFIED:
            self.integer_result = other.integer_result
        if other.pretty_result != "":
            self.pretty_result = other.pretty_result
        if preserve_initial:
            self.base_extra_data.update(other.base_extra_data)
        else:
            self.base_extra_data = other.base_extra_data

    def __eq__(self, other) -> bool:
        if not isinstance(other, type(self)):
            return False
        return self.base_extra_data == other.base_extra_data and \
               self.integer_result == other.integer_result and \
               self.pretty_result == other.pretty_result

    def __str__(self):
        return f'<result.Result: {self.integer_result}, ' \
               f'pretty: \'{self.pretty_result}\', ' \
               f'extra_data: {self.base_extra_data}'

    def to_dict(self) -> typing.Mapping[str, typing.Union[int, str, typing.Mapping]]:
        return {
            'integer_result': self.integer_result,
            'pretty_result': self.pretty_result,
            'extra_data': self.base_extra_data
        }
